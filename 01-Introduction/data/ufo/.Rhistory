points(which.max(pls.residuals),max(pls.residuals),
pch=10, col="red", cex=2)
pch=11, col="red", cex=2)
points(which.max(pls.residuals),max(pls.residuals),
pch=11, col="red", cex=2)
points(which.max(pls.residuals),max(pls.residuals),
pch=9, col="red", cex=2)
plot(pls.residuals, type="l", lwd=2,
main="PLS Test Residuals and Number of Components",
xlab="Number of Components", ylab="PLS Residual")
points(which.max(pls.residuals),max(pls.residuals),
pch=9, col="red", cex=2)
points(which.max(pls.residuals),max(pls.residuals),
pch=3, col="red", cex=2)
points(which.max(pls.residuals),max(pls.residuals),
pch=2, col="red", cex=2)
points(which.max(pls.residuals),max(pls.residuals),
pch=4, col="red", cex=2)
points(which.max(pls.residuals),max(pls.residuals),
pch=5, col="red", cex=2)
plot(pls.residuals, type="l", lwd=2,
main="PLS Test Residuals and Number of Components",
xlab="Number of Components", ylab="PLS Residual")
points(which.max(pls.residuals),max(pls.residuals),
pch=5, col="red", cex=2)
plot(pls.residuals, type="l", lwd=2,
main="PLS Test Residuals and Number of Components",
xlab="Number of Components", ylab="PLS Residual")
points(which.max(pls.residuals),max(pls.residuals),
pch=6, col="red", cex=2)
plot(pls.residuals, type="l", lwd=2,
main="PLS Test Residuals and Number of Components",
xlab="Number of Components", ylab="PLS Residual")
points(which.max(pls.residuals),max(pls.residuals),
pch=2, col="red", cex=2)
points(which.max(pls.residuals),max(pls.residuals),
pch=1, col="red", cex=1.5)
plot(pls.residuals, type="l", lwd=2,
main="PLS Test Residuals and Number of Components",
xlab="Number of Components", ylab="PLS Residual")
points(which.max(pls.residuals),max(pls.residuals),
pch=1, col="red", cex=1.5)
points(which.max(pls.residuals),max(pls.residuals),
pch=1, col="red", cex=1.5, lwd=2)
points(which.min(pls.valid$val), min(pls.valid$val), pch=10, col="red", cex=2)
plot(pls.valid)
points(which.min(pls.valid$val), min(pls.valid$val), pch=10, col="red", cex=2)
plot(pls.valid)
points(which.min(pls.valid$val), min(pls.valid$val),
pch=1, col="red", cex=1.5)
which.min(pls.valid$val)
validationplot(plsFit, val.type="RMSEP")
pls.valid <- RMSEP(plsFit, estimate="CV")
plot(pls.valid,)
points(which.min(pls.valid$val), min(pls.valid$val),
pch=1, col="red", cex=1.5)
points(which.min(pls.residuals),max(pls.residuals),
pch=1, col="red", cex=1.5, lwd=2)
points(which.min(pls.residuals),min(pls.residuals),
pch=1, col="red", cex=1.5, lwd=2)
min(pls.residuals)
which.min(pls.residuals)
library(MASS)
library(caret)
library(AppliedPredictiveModeling) # maxkuhn
library(lars)
library(pls)
library(elasticnet)
# load solubility data- training and test ####
data(solubility)
# add solubility Y values
training <- solTrainXtrans # transformed using Box-Cox
training$solubility <- solTrainY
plsFit <- plsr(solubility~., data=training, validation="CV")
pls.pred <- predict(plsFit, solTestXtrans[1:5,], ncomp=1:2)
library(MASS)
library(caret)
library(AppliedPredictiveModeling) # maxkuhn
library(lars)
library(pls)
library(elasticnet)
# load solubility data- training and test ####
data(solubility)
training <- solTrainXtrans # transformed using Box-Cox
training$solubility <- solTrainY
plsFit <- plsr(solubility~., data=training, validation="CV")
pls.pred <- predict(plsFit, solTestXtrans[1:5,], ncomp=1:2)
pls.valid <- RMSEP(plsFit, estimate="CV") # another way to find RMSEP + CV
plot(pls.valid, main="", xlab="components")
plot(pls.valid, main="RMSEP PLS Solubility", xlab="components")
points(which.min(pls.valid$val), min(pls.valid$val),
pch=1, col="red", cex=1.5)
min <- which.min(pls.valid$val) # lowest at 13 components
points(min, min(pls.valid$val), pch=1, col="red", cex=1.5)
pls.pred
type(plsFit)
typeof(plsFit)
library(MASS)
library(caret)
library(AppliedPredictiveModeling) # maxkuhn
library(lars)
library(pls)
library(elasticnet)
data(solubility)
training <- solTrainXtrans # transformed using Box-Cox
training$solubility <- solTrainY
plsFit <- plsr(solubility~., data=training, validation="CV")
pls.pred <- predict(plsFit, solTestXtrans[1:5,], ncomp=1:2)
pls.pred2 <- predict(plsFit, solTestXtrans, ncomp=13)
plot(pls.pred2, solTestY)
abline(0,1)
abline(0,1, col="red")
plot(pls.pred2, solTestY, ylim=c(-12,2), xlim=c(-12,2))
plot(pls.pred2, solTestY, ylim=c(-12,2), xlim=c(-10,2))
plot(solTestY, pls.pred2, ylim=c(-12,2), xlim=c(-10,2))
plot(solTestY, pls.pred2, ylim=c(-10,2), xlim=c(-12,2))
plot(solTestY, pls.pred2, ylim=c(-10,2), xlim=c(-11,2))
abline(0,1, col="red")
plot(solTestY, pls.pred2, ylim=c(-11,2), xlim=c(-11,2))
abline(0,1, col="red")
lm.eval <- data.frame(obs=solTestY, pred=pls.pred2)
defaultSummary(lm.eval)
attributes(pls.pred2)
str(pls.pred2)
lm.eval <- data.frame(obs=solTestY, pred=pls.pred2[,1,1])
defaultSummary(lm.eval)
pls.pred2[1:4,1,1]
plot(solTestY, pls.pred2, ylim=c(-11,2), xlim=c(-11,2),
main="Observed and PLS Predicted Solubilities")
abline(0,1, col="red")
plot(solTestY, pls.pred2, ylim=c(-11,2), xlim=c(-11,2),
main="Observed and PLS Predicted Solubilities",
xlab="Observed", ylab="PLS Predicted")
abline(0,1, col="red")
library(MASS)
library(caret)
library(AppliedPredictiveModeling) # maxkuhn
library(lars)
library(pls)
library(elasticnet)
# load solubility data- training and test ####
data(solubility)
training <- solTrainXtrans # transformed using Box-Cox
training$solubility <- solTrainY
plsFit <- plsr(solubility~., data=training, validation="CV")
pls.pred <- predict(plsFit, solTestXtrans[1:5,], ncomp=1:2)
validationplot(plsFit, val.type="RMSEP")
library(MASS)
library(caret)
library(AppliedPredictiveModeling) # maxkuhn
library(lars)
library(pls)
library(elasticnet)
data(solubility)
training <- solTrainXtrans # transformed using Box-Cox
training$solubility <- solTrainY
plsFit <- plsr(solubility~., data=training, validation="CV")
pls.pred <- predict(plsFit, solTestXtrans[1:5,], ncomp=1:2)
pls.RMSEP <- RMSEP(plsFit, estimate="CV") # another way to find RMSEP + CV
plot(pls.RMSEP, main="RMSEP PLS Solubility", xlab="components")
min <- which.min(pls.RMSEP$val) # lowest at 13 components
points(min, min(pls.RMSEP$val), pch=1, col="red", cex=1.5)
min
pls.RMSEP <- RMSEP(plsFit, estimate="CV") # another way to find RMSEP + CV
plot(pls.RMSEP, main="RMSEP PLS Solubility", xlab="components")
min <- which.min(pls.RMSEP$val) # lowest at 10 components
points(min, min(pls.RMSEP$val), pch=1, col="red", cex=1.5)
min
pls.RMSEP <- RMSEP(plsFit, estimate="CV") # another way to find RMSEP + CV
plot(pls.RMSEP, main="RMSEP PLS Solubility", xlab="components")
pls.residuals <- c()
for(x in 1:dim(plsFit$residuals)[3]){
pls.residuals[x] <- sum(plsFit$residuals[,,x])
}
plot(pls.residuals, type="l", lwd=2,
main="PLS Test Residuals and Number of Components",
xlab="Number of Components", ylab="PLS Residual")
which.min(pls.residuals)
points(which.min(pls.residuals),min(pls.residuals),
pch=1, col="red", cex=1.5, lwd=2)
plot(pls.residuals, type="l", lwd=2,
main="PLS Fit Residuals and Number of Components",
xlab="Number of Components", ylab="PLS Residual")
points(which.min(pls.residuals),min(pls.residuals),
pch=1, col="red", cex=1.5, lwd=2)
plsFit$loadings
summary(plsFit)
plot(plsFit, ncomp=10, asp=1, line=T)
summary(plsFit)
plot(pls.RMSEP, main="RMSEP PLS Solubility", xlab="components",
legendpos="topright")
plot(RMSEP(plsFit), legendpos="topright")
min <- which.min(pls.RMSEP$val) # lowest at 10 components
min
pls.pred2 <- predict(plsFit, solTestXtrans, ncomp=10)
plot(plsFit, ncomp=10, asp=1, line=T)
plot(solTestY, pls.pred2, ylim=c(-11,2), xlim=c(-11,2),
main="Observed and PLS Predicted Solubilities",
xlab="Observed", ylab="PLS Predicted")
abline(0,1, col="red")
pls.eval <- data.frame(obs=solTestY, pred=pls.pred2[,1,1])
defaultSummary(pls.eval)
97/3
97/4
97/6
97/7
97/9
97/11
97/12
97/13
phi(97)
2**3
8/2
8%3
8%%3
print("hello")
return 5
return(5)
c <- 0                   # encrypted code
p1 <- 5023               # prime 1
p2 <- 1783               # prime 2
n <- p1*p2               # public key 1
phi.n <- (p1-1)*(p2-1)   # phi of n
m <- 0                   # coded message
e <- 17                  # public key 2
d <- (2*phi.n+1)/e       # private key
n/e
## encrypt message
encrypt <- function(msg, pub.n = n, pub.e =e)  {
c <- (msg**pub.e)%%n
print("encrypted message:")
return(c)
}
encrypt(msg=89)
89^17
(89^17)%%n
c <- 0                   # encrypted code
p1 <- 11                 # prime 1
p2 <- 7                  # prime 2
n <- p1*p2               # public key 1
phi.n <- (p1-1)*(p2-1)   # phi of n
m <- 0                   # coded message
e <- 5                   # public key 2
d <- (2*phi.n+1)/e       # private key
encrypt <- function(msg, pub.n = n, pub.e =e)  {
c <- (msg**pub.e)%%n
print("encrypted message:")
return(c)
}
encrypt(msg=89)
decrypt <- function(c, priv = d) {
msg <- (c**d)%%n
print("decrypted message:")
return(msg)
}
decrypt(c=45)
c <- 0                   # encrypted code
p1 <- 11                 # prime 1
p2 <- 7                  # prime 2
n <- p1*p2               # public key 1
phi.n <- (p1-1)*(p2-1)   # phi of n
m <- 0                   # coded message
e <- 11                   # public key 2
d <- (2*phi.n+1)/e       # private key
encrypt(msg=89)
encrypt(msg=9)
decrypt(c=53)
53^11
(53^11)%%77
(53^11)/77
b <- 121
a1 <- 5
p <- 1
for(i = 1, i <= b) {
p <- p*a1
p <- p%%m
i <- i + 1
}
b <- 121
a1 <- 5
p <- 1; i <- 1
for(i <= b) {
p <- p*a1
p <- p%%m
i <- i + 1
}
b <- 121
a1 <- 5
p <- 1
for(i in 1:b) {
p <- p*a1
p <- p%%m
i <- i + 1
}
b <- 121
m <- 221
a1 <- 5
p <- 1
for(i in 1:b) {
p <- p*a1
p <- p%%m
i <- i + 1
}
p
(5^121)%%221
(5^121)
b <- 55
m <- 221
a1 <- 5
p <- 1
for(i in 1:b) {
p <- p*a1
p <- p%%m
i <- i + 1
}
p
625%%221
encrypt <- function(msg, pub.n = n, pub.e =e)  {
# c <- (msg**pub.e)%%n
p <- 1
a1 <- msg
for(i in 1:pub.e){
p <- p*a1
p <- p%%pub.n
i <- i + 1
}
print("encrypted message:")
return(p)
}
## decrypt message
decrypt <- function(c, priv = d) {
# msg <- (c**d)%%n
p <- 1
a1 <- c
for(i in 1:d){
p <- p*a1
p <- p%%n
i <- i + 1
}
print("decrypted message:")
return(p)
}
c <- 0                   # encrypted code
p1 <- 11                 # prime 1
p2 <- 7                  # prime 2
n <- p1*p2               # public key 1
phi.n <- (p1-1)*(p2-1)   # phi of n
m <- 0                   # coded message
e <- 11                  # public key 2
d <- (2*phi.n+1)/e       # private key
encrypt(10)
decrypt(54)
encrypt <- function(msg)  {
# c <- (msg**pub.e)%%n
p <- 1
a1 <- msg
for(i in 1:e){
p <- p*a1
p <- p%%n
i <- i + 1
}
print("encrypted message:")
return(p)
}
decrypt <- function(c) {
# msg <- (c**d)%%n
p <- 1
a1 <- c
for(i in 1:d){
p <- p*a1
p <- p%%n
i <- i + 1
}
print("decrypted message:")
return(p)
}
p1 <- 971                # prime 1
p2 <- 383                # prime 2
n <- p1*p2               # public key 1
phi.n <- (p1-1)*(p2-1)   # phi of n
m <- 0                   # coded message
e <- 17                  # public key 2
d <- (2*phi.n+1)/e       # private key
encrypt(33)
decrypt(365504)
5^55
(5^55)%%221
b <- 55
m <- 221
a1 <- 5
p <- 1
for(i in 1:b) {
p <- p*a1
p <- p%%m
i <- i + 1
}
p
p1 <- 971                # prime 1
p2 <- 383                # prime 2
n <- p1*p2               # public key 1
phi.n <- (p1-1)*(p2-1)   # phi of n
e <- 17                  # public key 2
d <- (2*phi.n+1)/e       # private key
encrypt <- function(msg)  {
# c <- (msg**pub.e)%%n
p <- 1
a1 <- msg
for(i in 1:e){
p <- p*a1
p <- p%%n
i <- i + 1
}
print("encrypted message:")
return(p)
}
encrypt(89)
decrypt <- function(c) {
# msg <- (c**d)%%n
p <- 1
a1 <- c
for(i in 1:d){
p <- p*a1
p <- p%%n
i <- i + 1
}
print("decrypted message:")
return(p)
}
decrypt(154827)
library(nnet)
library(neuralnet)
library(RSNNS)
str(laser)
library("AppliedPredictiveModeling", lib.loc="C:/Users/wayne/R/win-library/3.0")
library("e1071", lib.loc="C:/Users/wayne/R/win-library/3.0")
library(caret)
library(RSNNS)
laser
data("snnsData")
names(snnsData)
str(laser_999)
str(snnsData$laser_999.pat)
laser <- (snnsData$laser_999.pat)
head(laser)
plot(laser[,1], type="l")
plot(laser[,2], type="l")
librar(ggplot2)
library(ggplot2)
data(diamonds)
str(diamonds)
head(diamonds)
unique(diamonds$cut)
summary(diamonds$cut)
summary(diamonds$clarity)
summary(diamonds$color)
install.packages("maps")
install.packages("mapdata")
install.packages("maptools")
install.packages("mapproj")
install.packages("raster")
library(ggplot2)
install.packages("gpclib")
library(map)
library(maps)
library(mapdata)
map("WorldHires", "Mexico",)
map("worldHires", "Mexico", xlim=c(-118.4, -86.7), ylim=c(14.5321, 32.71865), col="blue", fill=True)
map("worldHires", "Mexico", xlim=c(-118.4, -86.7), ylim=c(14.5321, 32.71865), col="blue", fill=TRUE)
str(worldHires)
str('worldHires')
str(worldHires)
data(worldHires)
data(worldHiresMapEnv)
str(worldHires)
str(worldHiresMapEnv)
map("worldHires", "Canada", xlim=c(-141, -53), ylim=c(40,85), col="gray90",fill=T)
install.packages("rgdal")
install.packages("rgeos")
install.packages("spdep")
install.packages("spatstat")
install.packages("sp")
library(ggplot2)
library(RSNNS)
head(diamonds)
install.packages("RHIPE")
install.packages("party")
library(ggplot2)
setwd("~/Documents/R/hackers/data/01-Introduction/data/ufo")
load("allsightings.RData")
library(ggplot2)
library(png)
state.plot <- ggplot(all.sightings, aes(x=YearMonth, y=Sightings))+
geom_line(aes(color="db"))+
facet_wrap(~State, nrow=10, ncol=5)+
theme_bw()+
scale_color_manual(values=c("db"="darkblue"))+
scale_x_date(breaks="5 years", labels=date_format("%Y"), legend=NULL)+
xlab("Time")+
ylab("Number of Sightings")+
labs(title="Number of UFO Sightings by Month-Year and U.S. State (1990-2010)")
library(scales)
state.plot <- ggplot(all.sightings, aes(x=YearMonth, y=Sightings))+
geom_line(aes(color="db"))+
facet_wrap(~State, nrow=10, ncol=5)+
theme_bw()+
scale_color_manual(values=c("db"="darkblue"))+
scale_x_date(breaks="5 years", labels=date_format("%Y"), legend=NULL)+
# legend or guide? book is old ggplot 0.8.9
xlab("Time")+
ylab("Number of Sightings")+
labs(title="Number of UFO Sightings by Month-Year and U.S. State (1990-2010)")
print(state.plot)
